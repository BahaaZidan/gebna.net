## Highest Priority
 - [x] The JMAP request validator rejects the `createdIds` property entirely (`apps/backend/src/jmap.routes.ts:108-150`), so clients cannot pass creation maps from earlier requests even though RFC 8620 §3.3 mandates servers accept and use it. Allow `createdIds` on the Request object, seed the per-request creation-reference map with its entries, and expose those ids to every handler.
 - [x] The JMAP response builder never returns a `createdIds` map (`apps/backend/src/jmap.routes.ts:420-520`), so clients that supplied the field never get the merged creation ids RFC 8620 §3.4 requires. Accumulate every successful create’s mapping and include `createdIds` in the top-level response whenever the request contained that property.
- [x] `Email/query` only supports a subset of the RFC 8621 §4.4.1 filter keys (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:61-210`): it expects non-standard names like `sizeLarger`/`sizeSmaller` and completely ignores the required `minSize`/`maxSize`, `notKeyword`, `header`, and the thread keyword predicates (`allInThreadHaveKeyword`, `someInThreadHaveKeyword`, `noneInThreadHaveKeyword`). Accept the canonical property names, implement the missing predicates, and keep `emailsListSortOptions` in sync so clients can issue spec-compliant filters.
- [x] The `after` filter in `Email/query` is implemented with a strict `>` comparison (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:472-480`), but RFC 8621 §4.4.1 says it must match emails “the same or after” the given timestamp. Switch to an inclusive `>=` comparison so messages received exactly at the boundary aren’t erroneously excluded.
- [x] `EmailSubmission` never exposes per-recipient delivery data even though RFC 8621 §7.1 defines `deliveryStatus` as a map keyed by recipient address: we only store a single `DeliveryStatusRecord` blob in `email_submission.deliveryStatusJson` and return it verbatim (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:334-381`, `email-submission-get.ts:1-120`, `apps/backend/src/lib/outbound/submission-queue.ts`). Capture status per RCPT TO, persist it as a `String[DeliveryStatus]` object, and have `EmailSubmission/get` return that map instead of one global status.
- [x] Every `/get` handler emits duplicate ids in `list`/`notFound` when the client repeats an id (see `apps/backend/src/lib/jmap/method-handlers/email-get.ts:441-459`, `thread-get.ts:82-110`, `mailbox-get.ts:123-210`, etc.), but RFC 8620 §5.1 requires each id appear at most once. Deduplicate results for all `Foo/get` implementations before building the response arrays.
- [x] When clients omit `ids`, the `/get` handlers quietly truncate the default list to `maxObjectsInGet` (e.g., the `ids === null` paths in `apps/backend/src/lib/jmap/method-handlers/email-get.ts:103-136`, `thread-get.ts:33-67`, `email-submission-get.ts:24-66`, `push-subscription-get.ts:44-76`) instead of either returning all objects or failing with `requestTooLarge` as RFC 8620 §5.1 describes. Detect when the dataset exceeds the advertised limit and reject the call instead of returning a partial list.
- [x] All of the limit guards return a non-standard `"limitExceeded"` error (`apps/backend/src/lib/jmap/method-handlers/email-get.ts:122-128`, `thread-get.ts:41-47`, `email-set.ts:73-103`, `push-subscription-set.ts:44-70`, etc.), but RFC 8620 §§5.1 and 5.3 mandate the standard `"requestTooLarge"` error when a /get or /set exceeds the advertised limits. Replace the custom error type everywhere these guard rails fire.
- [x] `EmailSubmission` objects omit the required `threadId`, `dsnBlobIds`, and `mdnBlobIds` properties entirely: the schema doesn’t store them (`apps/backend/src/db/schema.ts:360-384`), and `EmailSubmission/get` refuses to return them (`apps/backend/src/lib/jmap/method-handlers/email-submission-get.ts:12-53`). RFC 8621 §7.1 defines all three fields, so persist and expose them just like the other EmailSubmission properties.
- [x] The submission capability advertises `submissionExtensions` as a bare string array (`apps/backend/src/jmap.routes.ts:52-71`), but RFC 8621 §1.3.2 says it MUST be an object that maps EHLO extension names to their argument lists. Reshape the capability so clients can discover available SMTP extensions correctly.
- [x] There is no `EmailSubmission/query` or `EmailSubmission/queryChanges` implementation at all, even though RFC 8621 §§7.3–7.4 describe these mandatory methods for the EmailSubmission data type. Either wire up the query/queryChanges handlers or stop advertising the submission capability until they exist.
- [x] The JMAP request validator only accepts the `using` and `methodCalls` properties (`apps/backend/src/jmap.routes.ts:92-99`), so any other top-level property—even future standard fields—is rejected instead of being ignored as RFC 8620 §3.3 requires. Update `JmapRequestSchema` (and downstream handling) to tolerate additional top-level keys.
- [x] `Email/get`, `Thread/get`, and `EmailSubmission/get` treat `ids === null`/omitted the same as an empty array (`apps/backend/src/lib/jmap/method-handlers/email-get.ts:100`, `thread-get.ts:30`, `email-submission-get.ts:37`), so they never return the server-chosen default object set when clients omit `ids` per RFC 8620 `/get` semantics. Distinguish between `null`/`undefined` and `[]` and stream the default list (subject to `maxObjectsInGet`) instead of returning nothing.
- [x] All `/changes` handlers propagate `includeUpdatedProperties`, but `getChanges` always returns `updatedProperties: null` (`apps/backend/src/lib/jmap/utils.ts:44-134`), so clients never learn which properties changed even when they ask. Track and return the property names when the flag is true and plumb them through the responses.
- [x] `Email/changes`, `Mailbox/changes`, `Thread/changes`, and `EmailSubmission/changes` all swallow `cannotCalculateChanges` errors from `getChanges` and respond with a generic `serverError` (see `apps/backend/src/lib/jmap/method-handlers/email-changes.ts:33-62`, `mailbox-changes.ts:31-60`, `thread-changes.ts:31-60`, `email-submission-changes.ts:22-51`). Per RFC 8620 they must bubble the original `cannotCalculateChanges` so clients know to resync.
- [x] `Email/get` silently truncates `ids` to `maxObjectsInGet` (`apps/backend/src/lib/jmap/method-handlers/email-get.ts:100-108`) instead of returning the `limitExceeded` error RFC 8620 mandates. Enforce the cap up front and fail the call if the client asks for too many ids.
- [x] `Email/parse` enforces every `blobId` to exist in the caller’s account and never honours `allowMissingIds`; unknown ids simply go into `notParsable` (`apps/backend/src/lib/jmap/method-handlers/email-parse.ts:120-166`). RFC 8620 says `allowMissingIds` defaults to true and non-owned blobs should be returned in `notFound`, so stop requiring ownership and distinguish missing blobs.
- [x] `Email/parse` ignores the `allowMissingIds` argument entirely (it’s absent from `EmailParseArgsSchema`, `apps/backend/src/lib/jmap/method-handlers/email-parse.ts:21-39`), so clients can’t request a hard failure when a blob is missing as RFC 8620 §6.1.3 allows. Accept the flag and honour it when building `notFound`.
- [x] Middleware never exposes the request-scoped creation reference map to handlers other than `Email/set` (`apps/backend/src/lib/jmap/middlewares.ts:19-37` plus handler usage), so methods like `Mailbox/set`, `EmailSubmission/set`, `Email/copy`, etc., can’t resolve `#creationIds` at all. Pass `creationReferences` into every handler.
- [x] Result references of the form `{ "resultOf": "...", "name": "...", "path": "..." }` are completely unsupported: `cloneWithResultReferences` in `apps/backend/src/jmap.routes.ts:231-257` only rewrites strings beginning with `#`, so clients can’t use general result references per RFC 8620 §3.7.

## High Priority
- [x] The `inMailboxOtherThan` filter in `Email/query` only matches emails with no memberships in the supplied mailboxes (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:489-494`), but RFC 8621 defines it as “has at least one mailbox whose id is not in the list.” Update the SQL to `EXISTS` a mailbox_id not in the provided set so messages that are in both listed and unlisted mailboxes still match.
- [x] `Thread/get` returns `emailIds` ordered newest-first by `internalDate` (`apps/backend/src/lib/jmap/method-handlers/thread-get.ts:54-80`), but RFC 8621 requires the array to be in chronological order within the thread. Sort ascending (oldest first) so clients don’t have to reorder.
- [x] `EmailSubmission/set` advertises a delayed-send capability (`maxDelayedSend`), yet `sendAt` is accepted without checking the allowed window (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:297-324` after parsing at `:657-673`), allowing arbitrarily far-future schedules despite the stated limit. Reject creations whose `sendAt` exceeds the advertised `maxDelayedSend` per RFC 8621 §7.4.
- [x] `Email/import` mailboxIds cannot use `#` result references because `parseEmailImportCreate` only looks up literal ids and has no access to the request’s creation map (`apps/backend/src/lib/jmap/method-handlers/email-import.ts:178-218`). Support resolving `#mailboxCreationIds` so clients can import mail directly into mailboxes created earlier in the same request as required by RFC 8620 §3.7.
- [x] `Email/parse` neither enforces `maxObjectsInGet` for `blobIds` nor distinguishes missing blobs from parse failures—every unknown id is pushed into `notParsable` and the response never includes `notFound` (`apps/backend/src/lib/jmap/method-handlers/email-parse.ts:64-175`). Honor the object limit and return proper `notFound` vs `notParsable` lists.
- [x] `Email/copy` rejects intra-account copies unless the client redundantly supplies `fromAccountId` (`apps/backend/src/lib/jmap/method-handlers/email-copy.ts:62-68`), even though RFC 8620 says it defaults to the authenticated account. Allow `fromAccountId` to be omitted when copying within the same account instead of throwing `accountNotFound`.
- [x] `Email/copy` demands every creation patch include an explicit `mailboxIds` map and errors out if it’s empty (`apps/backend/src/lib/jmap/method-handlers/email-copy.ts:200-211`), so you can’t just inherit the source mailboxes as the spec permits. Default to the source email’s current mailbox set when the client omits the field. While updating this logic, also enforce `maxObjectsInSet` for the create map so oversized copies produce `limitExceeded`.
- [x] `onSuccessDestroyEmail`/`onSuccessUpdateEmail` references in `EmailSubmission/set` only resolve `#creationIds` from the same `EmailSubmission/create` call (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:800-842`). They should behave like any other result reference and be resolved against the request-wide creation reference map so follow-up operations can target ids returned by earlier method responses.
- [x] `Email/query` ignores the `collapseThreads` argument entirely (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:90-115`), and `Email/queryChanges` always reports `collapseThreads: false` (`apps/backend/src/lib/jmap/method-handlers/email-query-changes.ts:147-149`). Reject or implement collapsed queries instead of silently returning expanded results when the client explicitly requests thread collapsing.
- [x] `Blob/get` never enforces the `maxObjectsInGet` limit on `ids` (`apps/backend/src/lib/jmap/method-handlers/blob.ts:31-73`), so a client can fetch an unbounded number of blobs in one call instead of receiving the `limitExceeded` error RFC 8620 requires.
- [x] `Blob/copy` also ignores capability limits: it accepts arbitrarily large `blobIds` arrays and never checks `JMAP_BLOB_ACCOUNT_CAPABILITY.maxSizeBlobSet` or any per-request cap (`apps/backend/src/lib/jmap/method-handlers/blob.ts:256-305`), allowing clients to schedule unbounded copy jobs.
- [x] `Blob/lookup` requires a non-empty `typeNames` array (`apps/backend/src/lib/jmap/method-handlers/blob.ts:328-355`), but RFC 8620 makes that argument optional and says an omitted value means “all supported type names.” Support `null`/missing `typeNames` instead of throwing `invalidArguments`.
- [x] `Email/parse` never validates the `properties` argument—unknown property names are silently ignored because the code just drops them into a `Set` with no whitelist (`apps/backend/src/lib/jmap/method-handlers/email-parse.ts:56-100`). Per RFC 8620 `/parse` should reject invalid property names with `invalidArguments`.
- [x] `Mailbox/set` only resolves `#creationIds` against objects created earlier in the same method call (`apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:118-125`), so you can’t reference a mailbox id produced by an earlier method response in the same JMAP request when setting `parentId` or destroying a mailbox. Wire it up to the request-scoped creation reference map like `Email/set` does.
- [x] `Email/copy` doesn’t understand result references either: both the `id` of the email to copy and the `mailboxIds` map are forced to literal ids pulled from the database (`apps/backend/src/lib/jmap/method-handlers/email-copy.ts:200-262`), so clients can’t copy an email they just created or target a mailbox created earlier in the request. Resolve `#` references via the shared creation map.
- [x] `EmailSubmission/set` refuses to accept `emailId` values like `"#foo"` from earlier method responses (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:582-671`), meaning you can’t submit an email you just created until a subsequent JMAP request. Add creation reference resolution before querying `accountMessageTable`.
- [x] `emailsListSortOptions` in the Mail capability only lists `receivedAt` and `sentAt` (`apps/backend/src/lib/jmap/constants.ts:27-39`), yet `Email/query` happily accepts `"size"` sorts (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:61-90`). Either advertise `size` or reject unsupported sort properties per RFC 8621 §5.1.
- [x] The `hasKeyword` filter in `Email/query` is case-sensitive because the input is never normalized, while stored keywords are lower-cased in `splitKeywords` (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:66-125` vs. `buildKeywordCondition` at `:466-475`). Normalize filter keywords before querying so clients can use any casing as required by RFC 8621 §4.1.2.
- [x] `Email/query` responses never include the `collapseThreads` flag (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:31-210`), even though RFC 8621 requires the server to echo whether the results are collapsed. Add the boolean (default `false`) to every response.
- [x] When there is no Sent mailbox, `EmailSubmission/set` still generates a default `mailboxIds` patch that removes the Drafts mailbox without adding a replacement (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:884-918`). Applying that patch causes `Email/set` to reject the update because the Email would have zero mailboxes, so submissions from accounts without a Sent mailbox always fail. Skip the Drafts removal unless there’s another mailbox to add so RFC 8621 §7.4 behavior (“remove from Drafts *and* add to Sent”) is preserved.

## Medium Priority
- [x] `Blob/download` requires a `type` query parameter and re-sanitizes it (`apps/backend/src/jmap.routes.ts:520-567`), but RFC 8620 delegates the Content-Type to the uploaded blob metadata. Honour the stored blob type/name instead of forcing clients to echo it back.
- [x] `VacationResponse/get` always returns a record even if the account has never stored vacation settings (`apps/backend/src/lib/jmap/method-handlers/vacation-get.ts:37-70`), whereas RFC 8620 says the singleton only exists once created. Return an empty list with `"notFound":["singleton"]` until the user first sets a vacation response.
- [x] `Identity/set` fails to enforce unique email addresses per account: `parseIdentityCreate`/`parseIdentityUpdate` never check for duplicates (`apps/backend/src/lib/jmap/method-handlers/identity-set.ts:68-216`), so clients can create multiple identities with the same From address despite RFC 8621 §5.2 requiring uniqueness. 
- [x] `Mailbox/query` only recognizes `text`, `name`, and `role` filters (`apps/backend/src/lib/jmap/method-handlers/mailbox-query.ts:24-86`), but RFC 8621 requires support for at least `parentId` and `isSubscribed` too. Add those canonical filter keys (and reject unknown ones) so clients can narrow to a specific parent or subscription state.
- [x] `Mailbox/queryChanges` refuses to operate on any filtered query state by forcing `normalizedFilter.operator === "all"` (`apps/backend/src/lib/jmap/method-handlers/mailbox-query-changes.ts:62-101`), even though the spec permits filters as long as the same filter was used to generate the query state. Allow stored filters instead of returning `cannotCalculateChanges`.
- [x] Neither `Mailbox/set` nor `Identity/set` enforces the advertised `maxObjectsInSet` limit—there are no create/update/destroy counters or `limitExceeded` checks in `apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:230-520` or `identity-set.ts:258-396`. Add the same guard that `Email/set` and `EmailSubmission/set` already use so abusive clients can’t exceed server limits.
- [x] `Mailbox/set` allows renaming or destroying system mailboxes with a non-null `role`. Neither the update path nor the destroy loop (`apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:80-116` and `:452-505`) checks `existing.role`, so clients can delete the Inbox/Sent mailboxes even though RFC 8621 §2.2 says role mailboxes are server-defined and immutable. Reject such operations with `invalidProperties`.
- [x] `Mailbox/set` never checks mailbox name length against the published `maxSizeMailboxName` (255). `parseMailboxCreate`/`parseMailboxUpdate` in `apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:20-116` only trim the string, so overlong names are silently accepted instead of returning `invalidProperties/tooLong` per RFC 8621.
- [x] The Blob account capability claims `supportedTypeNames: ["Email"]` (`apps/backend/src/lib/jmap/constants.ts:52-58`), but `Blob/lookup` actually supports `"EmailBodyValue"` as well (`apps/backend/src/lib/jmap/method-handlers/blob.ts:326-414`). Advertise every supported type so clients know they can ask for body-value matches.
- [x] `Email/set` and `Email/import` never validate keyword names; `splitKeywords`/`normalizeKeywordName` in `apps/backend/src/lib/jmap/method-handlers/email-set.ts:1179-1262` and `email-import.ts:248-340` will store any string (including spaces/control characters) instead of enforcing the ASCII pattern mandated by RFC 8621 §2.7. Reject invalid keyword names with `invalidProperties`.
- [x] `PushSubscription/get` omits the `verificationCode` property entirely from returned records (`apps/backend/src/lib/jmap/method-handlers/push-subscription-get.ts:1-84`), so clients that lose the `set` response cannot retrieve the pending code as required by RFC 8620 §7.1. Include the field whenever a subscription has `verificationCode`.
- [x] `handleJmap` never enforces that `using` includes `urn:ietf:params:jmap:core`; it only rejects unknown capabilities (`apps/backend/src/jmap.routes.ts:315-333`). RFC 8620 §3 says the server MUST return `unknownCapability` if a required capability (like core) is missing, so add a check before processing method calls.
