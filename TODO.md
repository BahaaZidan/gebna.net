## Highest Priority
- [x] `Email/get`, `Thread/get`, and `EmailSubmission/get` treat `ids === null`/omitted the same as an empty array (`apps/backend/src/lib/jmap/method-handlers/email-get.ts:100`, `thread-get.ts:30`, `email-submission-get.ts:37`), so they never return the server-chosen default object set when clients omit `ids` per RFC 8620 `/get` semantics. Distinguish between `null`/`undefined` and `[]` and stream the default list (subject to `maxObjectsInGet`) instead of returning nothing.
- [x] All `/changes` handlers propagate `includeUpdatedProperties`, but `getChanges` always returns `updatedProperties: null` (`apps/backend/src/lib/jmap/utils.ts:44-134`), so clients never learn which properties changed even when they ask. Track and return the property names when the flag is true and plumb them through the responses.
- [x] `Email/changes`, `Mailbox/changes`, `Thread/changes`, and `EmailSubmission/changes` all swallow `cannotCalculateChanges` errors from `getChanges` and respond with a generic `serverError` (see `apps/backend/src/lib/jmap/method-handlers/email-changes.ts:33-62`, `mailbox-changes.ts:31-60`, `thread-changes.ts:31-60`, `email-submission-changes.ts:22-51`). Per RFC 8620 they must bubble the original `cannotCalculateChanges` so clients know to resync.
- [x] `Email/get` silently truncates `ids` to `maxObjectsInGet` (`apps/backend/src/lib/jmap/method-handlers/email-get.ts:100-108`) instead of returning the `limitExceeded` error RFC 8620 mandates. Enforce the cap up front and fail the call if the client asks for too many ids.
- [x] `Email/parse` enforces every `blobId` to exist in the caller’s account and never honours `allowMissingIds`; unknown ids simply go into `notParsable` (`apps/backend/src/lib/jmap/method-handlers/email-parse.ts:120-166`). RFC 8620 says `allowMissingIds` defaults to true and non-owned blobs should be returned in `notFound`, so stop requiring ownership and distinguish missing blobs.
- [x] `Email/parse` ignores the `allowMissingIds` argument entirely (it’s absent from `EmailParseArgsSchema`, `apps/backend/src/lib/jmap/method-handlers/email-parse.ts:21-39`), so clients can’t request a hard failure when a blob is missing as RFC 8620 §6.1.3 allows. Accept the flag and honour it when building `notFound`.
- [x] Middleware never exposes the request-scoped creation reference map to handlers other than `Email/set` (`apps/backend/src/lib/jmap/middlewares.ts:19-37` plus handler usage), so methods like `Mailbox/set`, `EmailSubmission/set`, `Email/copy`, etc., can’t resolve `#creationIds` at all. Pass `creationReferences` into every handler.
- [ ] Result references of the form `{ "resultOf": "...", "name": "...", "path": "..." }` are completely unsupported: `cloneWithResultReferences` in `apps/backend/src/jmap.routes.ts:231-257` only rewrites strings beginning with `#`, so clients can’t use general result references per RFC 8620 §3.7.

## High Priority
- [ ] The `inMailboxOtherThan` filter in `Email/query` only matches emails with no memberships in the supplied mailboxes (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:489-494`), but RFC 8621 defines it as “has at least one mailbox whose id is not in the list.” Update the SQL to `EXISTS` a mailbox_id not in the provided set so messages that are in both listed and unlisted mailboxes still match.
- [ ] `Thread/get` returns `emailIds` ordered newest-first by `internalDate` (`apps/backend/src/lib/jmap/method-handlers/thread-get.ts:54-80`), but RFC 8621 requires the array to be in chronological order within the thread. Sort ascending (oldest first) so clients don’t have to reorder.
- [ ] `EmailSubmission/set` advertises a delayed-send capability (`maxDelayedSend`), yet `sendAt` is accepted without checking the allowed window (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:297-324` after parsing at `:657-673`), allowing arbitrarily far-future schedules despite the stated limit. Reject creations whose `sendAt` exceeds the advertised `maxDelayedSend` per RFC 8621 §7.4.
- [ ] `Email/import` mailboxIds cannot use `#` result references because `parseEmailImportCreate` only looks up literal ids and has no access to the request’s creation map (`apps/backend/src/lib/jmap/method-handlers/email-import.ts:178-218`). Support resolving `#mailboxCreationIds` so clients can import mail directly into mailboxes created earlier in the same request as required by RFC 8620 §3.7.
- [ ] `Email/parse` neither enforces `maxObjectsInGet` for `blobIds` nor distinguishes missing blobs from parse failures—every unknown id is pushed into `notParsable` and the response never includes `notFound` (`apps/backend/src/lib/jmap/method-handlers/email-parse.ts:64-175`). Honor the object limit and return proper `notFound` vs `notParsable` lists.
- [ ] `Email/copy` rejects intra-account copies unless the client redundantly supplies `fromAccountId` (`apps/backend/src/lib/jmap/method-handlers/email-copy.ts:62-68`), even though RFC 8620 says it defaults to the authenticated account. Allow `fromAccountId` to be omitted when copying within the same account instead of throwing `accountNotFound`.
- [ ] `Email/copy` demands every creation patch include an explicit `mailboxIds` map and errors out if it’s empty (`apps/backend/src/lib/jmap/method-handlers/email-copy.ts:200-211`), so you can’t just inherit the source mailboxes as the spec permits. Default to the source email’s current mailbox set when the client omits the field. While updating this logic, also enforce `maxObjectsInSet` for the create map so oversized copies produce `limitExceeded`.
- [ ] `onSuccessDestroyEmail`/`onSuccessUpdateEmail` references in `EmailSubmission/set` only resolve `#creationIds` from the same `EmailSubmission/create` call (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:800-842`). They should behave like any other result reference and be resolved against the request-wide creation reference map so follow-up operations can target ids returned by earlier method responses.
- [ ] `Email/query` ignores the `collapseThreads` argument entirely (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:90-115`), and `Email/queryChanges` always reports `collapseThreads: false` (`apps/backend/src/lib/jmap/method-handlers/email-query-changes.ts:147-149`). Reject or implement collapsed queries instead of silently returning expanded results when the client explicitly requests thread collapsing.
- [ ] `Blob/get` never enforces the `maxObjectsInGet` limit on `ids` (`apps/backend/src/lib/jmap/method-handlers/blob.ts:31-73`), so a client can fetch an unbounded number of blobs in one call instead of receiving the `limitExceeded` error RFC 8620 requires.
- [ ] `Blob/copy` also ignores capability limits: it accepts arbitrarily large `blobIds` arrays and never checks `JMAP_BLOB_ACCOUNT_CAPABILITY.maxSizeBlobSet` or any per-request cap (`apps/backend/src/lib/jmap/method-handlers/blob.ts:256-305`), allowing clients to schedule unbounded copy jobs.
- [ ] `Blob/lookup` requires a non-empty `typeNames` array (`apps/backend/src/lib/jmap/method-handlers/blob.ts:328-355`), but RFC 8620 makes that argument optional and says an omitted value means “all supported type names.” Support `null`/missing `typeNames` instead of throwing `invalidArguments`.
- [ ] `Email/parse` never validates the `properties` argument—unknown property names are silently ignored because the code just drops them into a `Set` with no whitelist (`apps/backend/src/lib/jmap/method-handlers/email-parse.ts:56-100`). Per RFC 8620 `/parse` should reject invalid property names with `invalidArguments`.
- [ ] `Mailbox/set` only resolves `#creationIds` against objects created earlier in the same method call (`apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:118-125`), so you can’t reference a mailbox id produced by an earlier method response in the same JMAP request when setting `parentId` or destroying a mailbox. Wire it up to the request-scoped creation reference map like `Email/set` does.
- [ ] `Email/copy` doesn’t understand result references either: both the `id` of the email to copy and the `mailboxIds` map are forced to literal ids pulled from the database (`apps/backend/src/lib/jmap/method-handlers/email-copy.ts:200-262`), so clients can’t copy an email they just created or target a mailbox created earlier in the request. Resolve `#` references via the shared creation map.
- [ ] `EmailSubmission/set` refuses to accept `emailId` values like `"#foo"` from earlier method responses (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:582-671`), meaning you can’t submit an email you just created until a subsequent JMAP request. Add creation reference resolution before querying `accountMessageTable`.
- [ ] `emailsListSortOptions` in the Mail capability only lists `receivedAt` and `sentAt` (`apps/backend/src/lib/jmap/constants.ts:27-39`), yet `Email/query` happily accepts `"size"` sorts (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:61-90`). Either advertise `size` or reject unsupported sort properties per RFC 8621 §5.1.
- [ ] The `hasKeyword` filter in `Email/query` is case-sensitive because the input is never normalized, while stored keywords are lower-cased in `splitKeywords` (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:66-125` vs. `buildKeywordCondition` at `:466-475`). Normalize filter keywords before querying so clients can use any casing as required by RFC 8621 §4.1.2.
- [ ] `Email/query` responses never include the `collapseThreads` flag (`apps/backend/src/lib/jmap/method-handlers/email-query.ts:31-210`), even though RFC 8621 requires the server to echo whether the results are collapsed. Add the boolean (default `false`) to every response.
- [ ] When there is no Sent mailbox, `EmailSubmission/set` still generates a default `mailboxIds` patch that removes the Drafts mailbox without adding a replacement (`apps/backend/src/lib/jmap/method-handlers/email-submission-set.ts:884-918`). Applying that patch causes `Email/set` to reject the update because the Email would have zero mailboxes, so submissions from accounts without a Sent mailbox always fail. Skip the Drafts removal unless there’s another mailbox to add so RFC 8621 §7.4 behavior (“remove from Drafts *and* add to Sent”) is preserved.

## Medium Priority
- [ ] `Blob/download` requires a `type` query parameter and re-sanitizes it (`apps/backend/src/jmap.routes.ts:520-567`), but RFC 8620 delegates the Content-Type to the uploaded blob metadata. Honour the stored blob type/name instead of forcing clients to echo it back.
- [ ] `VacationResponse/get` always returns a record even if the account has never stored vacation settings (`apps/backend/src/lib/jmap/method-handlers/vacation-get.ts:37-70`), whereas RFC 8620 says the singleton only exists once created. Return an empty list with `"notFound":["singleton"]` until the user first sets a vacation response.
- [ ] `Identity/set` fails to enforce unique email addresses per account: `parseIdentityCreate`/`parseIdentityUpdate` never check for duplicates (`apps/backend/src/lib/jmap/method-handlers/identity-set.ts:68-216`), so clients can create multiple identities with the same From address despite RFC 8621 §5.2 requiring uniqueness.
- [ ] `Mailbox/query` only recognizes `text`, `name`, and `role` filters (`apps/backend/src/lib/jmap/method-handlers/mailbox-query.ts:24-86`), but RFC 8621 requires support for at least `parentId` and `isSubscribed` too. Add those canonical filter keys (and reject unknown ones) so clients can narrow to a specific parent or subscription state.
- [ ] `Mailbox/queryChanges` refuses to operate on any filtered query state by forcing `normalizedFilter.operator === "all"` (`apps/backend/src/lib/jmap/method-handlers/mailbox-query-changes.ts:62-101`), even though the spec permits filters as long as the same filter was used to generate the query state. Allow stored filters instead of returning `cannotCalculateChanges`.
- [ ] Neither `Mailbox/set` nor `Identity/set` enforces the advertised `maxObjectsInSet` limit—there are no create/update/destroy counters or `limitExceeded` checks in `apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:230-520` or `identity-set.ts:258-396`. Add the same guard that `Email/set` and `EmailSubmission/set` already use so abusive clients can’t exceed server limits.
- [ ] `Mailbox/set` allows renaming or destroying system mailboxes with a non-null `role`. Neither the update path nor the destroy loop (`apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:80-116` and `:452-505`) checks `existing.role`, so clients can delete the Inbox/Sent mailboxes even though RFC 8621 §2.2 says role mailboxes are server-defined and immutable. Reject such operations with `invalidProperties`.
- [ ] `Mailbox/set` never checks mailbox name length against the published `maxSizeMailboxName` (255). `parseMailboxCreate`/`parseMailboxUpdate` in `apps/backend/src/lib/jmap/method-handlers/mailbox-set.ts:20-116` only trim the string, so overlong names are silently accepted instead of returning `invalidProperties/tooLong` per RFC 8621.
- [ ] The Blob account capability claims `supportedTypeNames: ["Email"]` (`apps/backend/src/lib/jmap/constants.ts:52-58`), but `Blob/lookup` actually supports `"EmailBodyValue"` as well (`apps/backend/src/lib/jmap/method-handlers/blob.ts:326-414`). Advertise every supported type so clients know they can ask for body-value matches.
- [ ] `Email/set` and `Email/import` never validate keyword names; `splitKeywords`/`normalizeKeywordName` in `apps/backend/src/lib/jmap/method-handlers/email-set.ts:1179-1262` and `email-import.ts:248-340` will store any string (including spaces/control characters) instead of enforcing the ASCII pattern mandated by RFC 8621 §2.7. Reject invalid keyword names with `invalidProperties`.
- [ ] `PushSubscription/get` omits the `verificationCode` property entirely from returned records (`apps/backend/src/lib/jmap/method-handlers/push-subscription-get.ts:1-84`), so clients that lose the `set` response cannot retrieve the pending code as required by RFC 8620 §7.1. Include the field whenever a subscription has `verificationCode`.
- [ ] `handleJmap` never enforces that `using` includes `urn:ietf:params:jmap:core`; it only rejects unknown capabilities (`apps/backend/src/jmap.routes.ts:315-333`). RFC 8620 §3 says the server MUST return `unknownCapability` if a required capability (like core) is missing, so add a check before processing method calls.
